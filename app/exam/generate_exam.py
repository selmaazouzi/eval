import pandas as pd
import logging
import json
from typing import Dict, Any, List

from .load_questions import load_questions
from .filters import filter_by_column, filter_code_questions
from .adjust_duration import adjust_duration
from .filter_by_tags_and_type import filter_by_tag_and_type
from .ai_exam_generator.freeform_choice_exam_generator import freeform_exam_generator, choice_exam_generator
from .ai_exam_generator.code_exam_generator import code_exam_generator
from .ai_question_generator.faiss.vectorstore import load_vectorstore
from .ai_question_generator.faiss.build_vectorstore import build_vectorstore

# Configure the logger
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


def generate_ai_questions(params: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Generate AI-based questions (freeform, choice, code) based on input parameters.

    Args:
        params (Dict[str, Any]): Dictionary containing exam generation parameters,
                                 such as difficulty, category, and generation structure.

    Returns:
        List[Dict[str, Any]]: A list of questions generated by the AI models.
    """
    ai_questions = []

    # Separate lists to log quantity by type
    ai_freeform_questions = []
    ai_choice_questions = []

    difficulty = params.get('difficulty')
    category = params.get('category')
    vectorstore = load_vectorstore()

    # Handle generation of freeform and choice questions
    generate_exam = params.get('generateExam')
    if generate_exam:
        ai_freeform_questions = freeform_exam_generator(generate_exam, difficulty, category, vectorstore)
        ai_questions.extend(ai_freeform_questions)

        ai_choice_questions = choice_exam_generator(generate_exam, difficulty, category, vectorstore)
        ai_questions.extend(ai_choice_questions)

    # Handle generation of code questions if present
    code_params = params.get('questionCode')
    if code_params:
        ai_code_questions = code_exam_generator(code_params, difficulty, category, vectorstore)
        ai_questions.extend(ai_code_questions)

    return ai_questions


def generate(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Full exam generation pipeline:
    - Load existing questions from DB
    - Filter by difficulty, tag, type
    - Adjust to fit target duration
    - Generate complementary AI-based questions

    Args:
        params (Dict[str, Any]): Parameters including userGroupId, difficulty, duration,
                                 generateExam structure, and code config.

    Returns:
        Dict[str, Any]: Exam structure containing selected and AI-generated questions,
                        total number of questions, and adjusted total duration.
    """
    logger.info("Starting exam generation with params: %s", params)

    # Load question base for the specific user group
    user_group_id = params.get('userGroupId')
    logger.info("Loading questions for user group ID: %s", user_group_id)
    df = load_questions(user_group_id)
    logger.info("Loaded %d questions", len(df))

    # First filtering: by difficulty level
    selected_questions_code_by_difficulty = filter_by_column(df, 'difficulty', params.get('difficulty'))
    logger.info("Filtered questions by difficulty: %d", len(selected_questions_code_by_difficulty))

    # Further filter: extract code-related questions
    code_questions = filter_code_questions(selected_questions_code_by_difficulty, params)
    logger.info("Selected code questions: %d", len(code_questions))

    # Filter other questions based on tags and type (freeform, choice)
    selected_questions = filter_by_tag_and_type(df, params['generateExam'], params.get('difficulty'))
    logger.info("Filtered by tag and type: %d", len(selected_questions))

    # Combine code and tag-based filtered questions
    selected_questions = pd.concat([selected_questions, code_questions])
    logger.info("Total selected questions after merge: %d", len(selected_questions))

    if selected_questions.empty:
        logger.warning("No questions selected after filtering")
        return {
            'number_of_questions': 0,
            'adjusted_duration': 0,
            'questions': []
        }

    # Convert target duration from minutes to seconds
    target_duration = params.get('duration', 0) * 60
    logger.info("Target duration in seconds: %d", target_duration)

    # Adjust selection to match the duration constraint
    selected_questions = adjust_duration(selected_questions, target_duration)
    logger.info("Final number of questions: %d, Adjusted duration: %d",
                len(selected_questions), int(selected_questions['time_limit'].sum()))

    # Extract final time limit after adjustment
    time_limit = int(selected_questions['time_limit'].sum())

    # Convert to dict for response formatting
    selected_questions = selected_questions.to_dict('records')

    # Vectorization and embedding of the table question
    df_ai = pd.read_csv("app/exam/ai_question_generator/faiss/data/questions.csv")
    build_vectorstore(df_ai, output_dir="app/exam/ai_question_generator/faiss/faiss_index")
    # Generate additional questions using AI models
    ai_questions = generate_ai_questions(params)
    
    # Convert JSON strings (if any) to dicts
    ai_questions = [json.loads(q) if isinstance(q, str) else q for q in ai_questions]

    # Extract time_limit from AI questions
    time_limit_ai = sum(int(q.get('time_limit', 0)) for q in ai_questions)
    logger.info("Total time limit for AI questions: %d", time_limit_ai)

    time_limit += time_limit_ai
    logger.info("Total adjusted time limit after AI questions: %d", time_limit)
    
    return {
        'number_of_questions': len(selected_questions),
        'adjusted_duration': time_limit,
        'questions': selected_questions,
        'questions_ia': ai_questions
    }
